"""
utils.py

This module contains utility functions for preprocessing data, adding constraints, and
performing other operations necessary for solving the CSP-S problem.
"""

import numpy as np
import gurobipy as grb


def merge_equal_lengths(lengths, demands):
    """
    Merge items of equal lengths by combining their demands.

    :param lengths: List of item lengths.
    :param demands: List of item demands.
    :return: New lengths and demands after merging items with the same lengths.
    """
    merged_data = {}
    for length, demand in zip(lengths, demands):
        if length in merged_data:
            merged_data[length] += demand
        else:
            merged_data[length] = demand

    merged_lengths = list(merged_data.keys())
    merged_demands = list(merged_data.values())

    return np.array(merged_lengths, dtype=int), np.array(merged_demands, dtype=int)


def symmetry_break_constraints(model, lambda_vars):
    """
    Add symmetry-breaking constraints to the ILP model to prevent redundant solutions.

    :param model: Gurobi ILP model object.
    :param lambda_vars: Dictionary of binary variables Î»_kj,
                        where keys are (k, j) tuples representing pattern k and frequency j.
    :return: None
    """
    # Group variables by pattern index for frequency comparisons
    grouped_vars = {}
    for (k, j), var in lambda_vars.items():
        if k not in grouped_vars:
            grouped_vars[k] = []
        grouped_vars[k].append((j, var))

    # Sort frequencies in descending order for each pattern
    for k, vars_group in grouped_vars.items():
        grouped_vars[k] = sorted(vars_group, key=lambda x: x[0], reverse=True)

    # Add symmetry-breaking constraints
    keys = sorted(grouped_vars.keys())
    for i in range(len(keys) - 1):
        k = keys[i]
        next_k = keys[i + 1]
        model.addConstr(
            grb.quicksum(j * var for j, var in grouped_vars[k]) >=
            grb.quicksum(j * var for j, var in grouped_vars[next_k]),
            name=f"symmetry_break_k{k}_k{next_k}"
        )


def preprocess_instance(lengths, demands, max_length):
    """
    Perform preprocessing for CSP-S problem:
    1. Remove items with lengths greater than max_length.
    2. Merge items with the same length by summing their demands.

    :param lengths: List of item lengths.
    :param demands: List of item demands.
    :param max_length: Maximum allowable sheet length.
    :return: Preprocessed lengths and corresponding demands.
    """
    # Step 1: Filter out items with lengths greater than maximum allowable length
    valid_indices = [i for i, l in enumerate(lengths) if l <= max_length]
    filtered_lengths = [lengths[i] for i in valid_indices]
    filtered_demands = [demands[i] for i in valid_indices]

    # Step 2: Merge items with equal lengths
    return merge_equal_lengths(filtered_lengths, filtered_demands)


def print_pareto_solutions(results):
    """
    Print the Pareto solutions for debugging and review.

    :param results: List of solutions generated by the Pareto framework,
                    where each solution is a dictionary with 'num_objects', 'num_patterns', and 'solution'.
    """
    print("\nPareto Optimal Solutions:")
    for idx, result in enumerate(results):
        print(f"Solution {idx + 1}:")
        print(f"  Number of Objects: {result['num_objects']}")
        print(f"  Number of Patterns: {result['num_patterns']}")
        print(f"  Solution Details: {result['solution']}")
        print("-" * 40)
