#!/usr/bin/env python3
"""
Heuristic candidate generators used to augment CE's candidate set.

This module provides:
 - random_feasible: random multinomial feasible samples
 - heuristic_fill_low_inventory: samples candidates and selects those that
   improve the most on low-inventory (urgent) items by simulating on a deepcopy.
 - generate_heuristic_candidates: wrapper that returns a list of candidate x arrays.
"""
import copy
import numpy as np

def random_action_sample(env, rng, xtotal=None):
    n = getattr(env, 'n', getattr(env, 'num_patterns', None))
    if n is None:
        # try infer from x_max with fallback
        n = getattr(env, 'n', 15)
    if xtotal is None:
        xtotal = int(rng.integers(0, getattr(env, 'x_max', 10) + 1))
    if xtotal == 0:
        return np.zeros(n, dtype=int)
    p = np.ones(n, dtype=float) / float(n)
    return rng.multinomial(int(xtotal), p)

def random_feasible(env, rng, max_attempts=200):
    for _ in range(max_attempts):
        xtotal = int(rng.integers(0, getattr(env, 'x_max', 10) + 1))
        x = random_action_sample(env, rng, xtotal=xtotal)
        try:
            if env.is_feasible(x):
                return x
        except Exception:
            # if env.is_feasible not available, accept sample
            return x
    n = getattr(env, 'n', getattr(env, 'num_patterns', 1))
    return np.zeros(n, dtype=int)

def heuristic_fill_low_inventory(env, rng, top_k=3, samples=200):
    """
    Sample random feasible actions and simulate them to pick those that
    most increase inventory of the most urgent (low-inv) items.

    Returns a single candidate x (best found). Use generate_heuristic_candidates
    to get multiple.
    """
    s_cur = env.s.copy()
    probs = np.array(getattr(env, 'demand_prob', [1.0]*len(s_cur)), dtype=float)
    urg = probs / (s_cur.astype(float) + 1.0)
    top_items = list(np.argsort(-urg)[:top_k])

    best_x = None
    best_score = -1e9

    for _ in range(samples):
        x_cand = random_feasible(env, rng, max_attempts=20)
        # simulate on deepcopy
        try:
            env_copy = copy.deepcopy(env)
            try:
                env_copy.reset(s_cur)
            except Exception:
                try:
                    env_copy.s = s_cur.copy()
                except Exception:
                    pass
            if not getattr(env_copy, 'is_feasible', lambda a: True)(x_cand):
                continue
            s_next, _, _ = env_copy.step(x_cand)
        except Exception:
            continue
        incr = s_next[top_items].astype(float) - s_cur[top_items].astype(float)
        score = float(incr.sum()) + 0.001 * float(x_cand.sum())
        if score > best_score:
            best_score = score
            best_x = x_cand.copy()

    if best_x is None:
        return random_feasible(env, rng, max_attempts=200)
    return best_x

def generate_heuristic_candidates(env, rng, num=5, top_k=3, samples_per=100):
    """
    Return a list of `num` candidate actions (numpy arrays) generated by:
     - a few random feasible samples
     - a few heuristic_fill_low_inventory samples
    """
    cands = []
    # add some random feasible
    n_rand = max(1, int(num * 0.4))
    for _ in range(n_rand):
        cands.append(random_feasible(env, rng, max_attempts=50))
    # rest from heuristic fill
    while len(cands) < num:
        cands.append(heuristic_fill_low_inventory(env, rng, top_k=top_k, samples=samples_per))
    # deduplicate (keep unique rows)
    uniq = []
    seen = set()
    for x in cands:
        key = tuple(int(v) for v in x)
        if key not in seen:
            seen.add(key)
            uniq.append(x)
    return uniq